TCP是字节流协议（创建SOCKT的时候指定），最小接收单元是字节
UDP是数据包协议，最小接收单元是包



#1 - syslogd使用的socket就是UNIX域socket，速度快
	(理解原理，或者学习如何使用syslogd，从而来利用到自己的项目中来)

#2 - 套接字创建的套接字描述符，默认是阻塞的，如果某个套接字当前不可用，那么“调用”套接字的时候就会阻塞。这里的”调用“有如下四种：
     1）读出操作，包括五个函数————read、readv、recv、recvfrom、recvmsg。如果某个进程对于阻塞套接字调用上述五个操作，而套接字的读缓冲区又没有数据可读。那么
        就会睡眠，知道有数据为止。
		(注意：上面说了，只要有数据就返回，TCP又是字节流的，那么可能就只有1个字节到了缓冲区，这个时候也返回，这样就需要循环读，那么如果想等到缓冲区
                 有N个字节了再跳出睡眠，并返回。要么使用readn，要么指定MSG_WAITALL标志)
     		(对于TCP，只要缓冲区有一个字节可读，都不会阻塞；对于UDP，只要缓冲区有一个包可读，都不会阻塞)
		(如果套接字描述符是非阻塞的，)
	(疑问：阻塞不阻塞到底是针对套接字而言？还是针对套接字描述符而言？实验：父子进程都打开某个套接字，父进程设置描述符为非阻塞，然后同时读，看子进程是否阻塞)
	(猜测：子进程阻塞？那么阻塞非阻塞是针对套接字描述符而言；子进程不阻塞？那么阻塞非阻塞是针对套接字而言)
	(结论：阻塞非阻塞是针对套接字“描述符”的，从使用fcntl这个函数就能看的出来)
     2）写入操作，包括五个函数————write、writev、send、sendto、sendmsg。
	在tcp场景下，如果缓冲区又1000个字节，已经被占了500个，然后现在要写进入600个，那么内核会从600个里面拿500写进去，然后会阻塞，需要再次调用write把剩下的100个写进去
     3）accept函数
     4）tcp的connect函数

